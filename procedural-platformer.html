<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Procedural Platformer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            overflow: hidden;
            background: #1a1a2e;
            font-family: 'Courier New', monospace;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }

        #gameCanvas {
            border: 3px solid #0f3460;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.3);
            image-rendering: pixelated;
            image-rendering: crisp-edges;
        }

        #menu {
            position: absolute;
            background: rgba(15, 52, 96, 0.95);
            padding: 40px;
            border-radius: 15px;
            text-align: center;
            color: #eee;
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.5);
        }

        #menu h1 {
            font-size: 48px;
            margin-bottom: 20px;
            color: #00ffff;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        }

        #menu button {
            background: #e94560;
            color: white;
            border: none;
            padding: 15px 40px;
            font-size: 20px;
            margin: 10px;
            cursor: pointer;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            transition: all 0.3s;
        }

        #menu button:hover {
            background: #ff6b81;
            transform: scale(1.05);
        }

        #seedInput {
            margin: 20px 0;
            padding: 10px;
            font-size: 16px;
            width: 200px;
            border: 2px solid #00ffff;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            border-radius: 5px;
        }

        #instructions {
            margin-top: 20px;
            font-size: 14px;
            line-height: 1.6;
        }

        .hidden {
            display: none;
        }

        #hud {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            font-size: 20px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
            z-index: 10;
        }
    </style>
</head>
<body>
    <div id="menu">
        <h1>🌟 PROCEDURAL PLATFORMER 🌟</h1>
        <button id="start1PBtn">🎮 1 Jogador</button>
        <button id="start2PBtn">👥 2 Jogadores</button>
        <button id="instructionsBtn">📖 Instruções</button>
        <div id="instructions" class="hidden">
            <p><strong>Controles 1 Jogador:</strong></p>
            <p>A D / ← → : Mover</p>
            <p>W / ↑ / ESPAÇO : Pular</p>
            <p><strong>Controles 2 Jogadores:</strong></p>
            <p>P1 (Azul): A D W</p>
            <p>P2 (Vermelho): ← → ↑</p>
            <p>ESPAÇO: Ambos pulam juntos!</p>
            <p>P : Pausar</p>
            <p><strong>Objetivo:</strong></p>
            <p>Colete moedas e chegue o mais longe possível!</p>
            <p>Derrote inimigos pulando sobre eles.</p>
            <p>Evite contato lateral com inimigos!</p>
            <p><strong>Power-ups:</strong></p>
            <p>🔵 Azul: Pulo mais alto (10s)</p>
            <p>🟢 Verde: Velocidade aumentada (10s)</p>
        </div>
    </div>

    <div id="hud" class="hidden">
        <div id="p1-hud">P1 🏆: <span id="p1-score">0</span> | 💖: <span id="p1-lives">3</span></div>
        <div id="p2-hud" style="display:none;">P2 🏆: <span id="p2-score">0</span> | 💖: <span id="p2-lives">3</span></div>
        <div>📏 Distância: <span id="distance">0</span>m</div>
    </div>

    <canvas id="gameCanvas" width="1280" height="720"></canvas>

    <script>
        // ============================================
        // PRNG - Gerador de números pseudo-aleatórios determinístico
        // ============================================
        class Random {
            constructor(seed) {
                this.seed = seed >>> 0; // Garante uint32
            }

            // Mulberry32 - PRNG rápido e simples
            next() {
                let t = this.seed += 0x6D2B79F5;
                t = Math.imul(t ^ t >>> 15, t | 1);
                t ^= t + Math.imul(t ^ t >>> 7, t | 61);
                return ((t ^ t >>> 14) >>> 0) / 4294967296;
            }

            range(min, max) {
                return min + this.next() * (max - min);
            }

            int(min, max) {
                return Math.floor(this.range(min, max + 1));
            }

            choice(array) {
                return array[this.int(0, array.length - 1)];
            }
        }

        // ============================================
        // CONSTANTES E CONFIGURAÇÕES
        // ============================================
        const CONFIG = {
            GRAVITY: 0.6,
            JUMP_STRENGTH: -13,
            MOVE_SPEED: 5,
            FRICTION: 0.85,
            PLAYER_WIDTH: 24,
            PLAYER_HEIGHT: 32,
            TILE_SIZE: 32,
            CHUNK_WIDTH: 30, // tiles por chunk
            VIEW_DISTANCE: 3, // chunks à frente/atrás
            COIN_SIZE: 16,
            ENEMY_SIZE: 28,
            STOMP_THRESHOLD: 0.3, // Velocidade mínima para stomp
        };

        // ============================================
        // GAME STATE
        // ============================================
        const game = {
            canvas: document.getElementById('gameCanvas'),
            ctx: null,
            width: 1280,
            height: 720,
            state: 'menu', // 'menu', 'playing', 'paused', 'gameover'
            seed: 0,
            random: null,
            keys: {},
            camera: { x: 0, y: 0, targetX: 0 },
            player: null,
            player2: null,
            twoPlayerMode: false,
            chunks: new Map(),
            entities: [],
            coins: [],
            enemies: [],
            powerups: [],
            particles: [],
            floatingTexts: [],
            score: 0,
            lives: 3,
            distance: 0,
            difficulty: 0,
            stats: {
                coinsCollected: 0,
                enemiesDefeated: 0,
                powerupsCollected: 0,
                lastDistance: 0
            },
            lastTime: 0,
            deltaTime: 0,
            devMode: {
                enabled: false,
                noclip: false,
                showHitboxes: false,
                showGrid: false,
                showInfo: true,
                invincible: false,
                flySpeed: 10,
                timeScale: 1.0,
                gravityEnabled: true,
                keySequence: [],
                lastKeyTime: 0
            }
        };

        // ============================================
        // PLAYER
        // ============================================
        class Player {
            constructor(x, y, playerNumber = 1) {
                this.x = x;
                this.y = y;
                this.vx = 0;
                this.vy = 0;
                this.width = CONFIG.PLAYER_WIDTH;
                this.height = CONFIG.PLAYER_HEIGHT;
                this.grounded = false;
                this.jumping = false;
                this.invulnerable = false;
                this.invulnerableTime = 0;
                this.jumpBoost = 1;
                this.jumpBoostTime = 0;
                this.speedBoost = 1;
                this.speedBoostTime = 0;

                // Multiplayer: definir número do jogador e controles
                this.playerNumber = playerNumber;
                this.color = playerNumber === 1 ? '#00d9ff' : '#ff6b6b';
                this.controls = playerNumber === 1 ?
                    { left: 'a', right: 'd', up: 'w' } :
                    { left: 'ArrowLeft', right: 'ArrowRight', up: 'ArrowUp' };

                // Stats individuais por jogador
                this.lives = 3;
                this.score = 0;
            }

            update() {
                // Atualizar power-ups
                if (this.jumpBoostTime > 0) {
                    this.jumpBoostTime--;
                    if (this.jumpBoostTime <= 0) {
                        this.jumpBoost = 1;
                    }
                }

                if (this.speedBoostTime > 0) {
                    this.speedBoostTime--;
                    if (this.speedBoostTime <= 0) {
                        this.speedBoost = 1;
                    }
                }

                // DEV MODE: Controles especiais
                if (game.devMode.enabled && game.devMode.noclip) {
                    const flySpeed = game.devMode.flySpeed;

                    // Voo livre (ignora física)
                    this.vx = 0;
                    this.vy = 0;

                    if (game.keys[this.controls.left]) {
                        this.x -= flySpeed;
                    }
                    if (game.keys[this.controls.right]) {
                        this.x += flySpeed;
                    }
                    if (game.keys[this.controls.up]) {
                        this.y -= flySpeed;
                    }
                    if (game.keys['s'] || game.keys['ArrowDown']) {
                        this.y += flySpeed;
                    }

                    // Não aplicar gravidade ou colisões no noclip
                    return;
                }

                // Controles normais
                let moveSpeed = CONFIG.MOVE_SPEED * this.speedBoost;
                if (game.devMode.enabled) moveSpeed *= 2; // Velocidade dobrada em dev mode

                if (game.keys[this.controls.left]) {
                    this.vx = -moveSpeed;
                } else if (game.keys[this.controls.right]) {
                    this.vx = moveSpeed;
                } else {
                    this.vx *= CONFIG.FRICTION;
                }

                // Pulo individual (W ou Seta para cima)
                if (game.keys[this.controls.up] && this.grounded && !this.jumping) {
                    let jumpStrength = CONFIG.JUMP_STRENGTH * this.jumpBoost;
                    if (game.devMode.enabled) jumpStrength *= 1.5; // Super pulo em dev mode
                    this.vy = jumpStrength;
                    this.jumping = true;
                    this.grounded = false;
                }

                // Pulo conjunto (ESPAÇO faz ambos pularem)
                if (game.keys[' '] && this.grounded && !this.jumping) {
                    let jumpStrength = CONFIG.JUMP_STRENGTH * this.jumpBoost;
                    if (game.devMode.enabled) jumpStrength *= 1.5;
                    this.vy = jumpStrength;
                    this.jumping = true;
                    this.grounded = false;
                }

                if (!game.keys[this.controls.up] && !game.keys[' ']) {
                    this.jumping = false;
                }

                // Gravidade (pode ser desativada em dev mode)
                if (game.devMode.gravityEnabled) {
                    this.vy += CONFIG.GRAVITY;
                }

                // Limites de velocidade
                if (this.vy > 20) this.vy = 20;

                // Atualizar posição
                this.x += this.vx;
                this.y += this.vy;

                // Colisões com terreno
                this.grounded = false;
                this.handleCollisions();

                // Limites do mundo
                if (this.y > game.height + 100) {
                    this.die();
                }

                // Invulnerabilidade
                if (this.invulnerable) {
                    this.invulnerableTime--;
                    if (this.invulnerableTime <= 0) {
                        this.invulnerable = false;
                    }
                }

                // Atualizar distância e pontuar (baseado no jogador mais à direita)
                const rightmostX = game.twoPlayerMode && game.player2 ?
                    Math.max(game.player.x, game.player2.x) :
                    this.x;

                const newDistance = Math.floor(rightmostX / CONFIG.TILE_SIZE);
                if (newDistance > game.distance) {
                    const distanceDiff = newDistance - game.distance;
                    // Jogador mais à direita ganha os pontos de distância
                    if (game.twoPlayerMode && game.player2) {
                        if (game.player.x > game.player2.x) {
                            game.player.score += distanceDiff;
                        } else {
                            game.player2.score += distanceDiff;
                        }
                    } else {
                        this.score += distanceDiff;
                    }
                    game.distance = newDistance;
                }
                game.difficulty = Math.floor(game.distance / 100); // Aumenta a cada 100 tiles
            }

            handleCollisions() {
                const startChunk = Math.floor((this.x - 200) / (CONFIG.CHUNK_WIDTH * CONFIG.TILE_SIZE));
                const endChunk = Math.floor((this.x + 200) / (CONFIG.CHUNK_WIDTH * CONFIG.TILE_SIZE));

                for (let chunkIdx = startChunk; chunkIdx <= endChunk; chunkIdx++) {
                    const chunk = game.chunks.get(chunkIdx);
                    if (!chunk) continue;

                    chunk.platforms.forEach(platform => {
                        if (this.intersects(platform)) {
                            // Detectar de que lado veio a colisão
                            const overlapLeft = (this.x + this.width) - platform.x;
                            const overlapRight = (platform.x + platform.width) - this.x;
                            const overlapTop = (this.y + this.height) - platform.y;
                            const overlapBottom = (platform.y + platform.height) - this.y;

                            const minOverlap = Math.min(overlapLeft, overlapRight, overlapTop, overlapBottom);

                            // Colisão vertical
                            if (minOverlap === overlapTop && this.vy > 0) {
                                this.y = platform.y - this.height;
                                this.vy = 0;
                                this.grounded = true;
                            }
                            // Head bump
                            else if (minOverlap === overlapBottom && this.vy < 0) {
                                this.y = platform.y + platform.height;
                                this.vy = 0;
                            }
                            // Colisão horizontal
                            else if (minOverlap === overlapLeft) {
                                this.x = platform.x - this.width;
                                this.vx = 0;
                            }
                            else if (minOverlap === overlapRight) {
                                this.x = platform.x + platform.width;
                                this.vx = 0;
                            }
                        }
                    });
                }
            }

            intersects(rect) {
                return this.x < rect.x + rect.width &&
                       this.x + this.width > rect.x &&
                       this.y < rect.y + rect.height &&
                       this.y + this.height > rect.y;
            }

            takeDamage() {
                if (this.invulnerable) return;
                if (game.devMode.enabled && game.devMode.invincible) return; // Dev Mode: invencível

                this.lives--;

                // Atualizar HUD apropriado
                if (this.playerNumber === 1) {
                    document.getElementById('p1-lives').textContent = this.lives;
                } else {
                    document.getElementById('p2-lives').textContent = this.lives;
                }

                if (this.lives <= 0) {
                    this.die();
                } else {
                    this.invulnerable = true;
                    this.invulnerableTime = 90; // 1.5 segundos a 60fps
                    this.vy = CONFIG.JUMP_STRENGTH * 0.7;
                }
            }

            die() {
                if (game.devMode.enabled && game.devMode.invincible) return; // Dev Mode: não morre

                // Em modo 2 jogadores, verificar se o outro ainda está vivo
                if (game.twoPlayerMode) {
                    const otherPlayer = this.playerNumber === 1 ? game.player2 : game.player;
                    if (otherPlayer && otherPlayer.lives > 0) {
                        // Outro jogador ainda vivo, não game over
                        console.log(`Player ${this.playerNumber} morreu, mas Player ${otherPlayer.playerNumber} continua!`);
                        this.lives = 0;
                        // Jogador morto continua no jogo mas não pode mais ser controlado
                        return;
                    }
                }

                // Game over (modo 1P ou ambos morreram em 2P)
                game.state = 'gameover';
                showGameOver();
            }

            draw(ctx) {
                // Efeito de piscar quando invulnerável
                if (this.invulnerable && Math.floor(this.invulnerableTime / 5) % 2 === 0) {
                    return;
                }

                const screenX = this.x - game.camera.x;
                const screenY = this.y - game.camera.y;

                // Aura de power-up
                if (this.jumpBoostTime > 0) {
                    ctx.fillStyle = 'rgba(0, 217, 255, 0.3)';
                    ctx.shadowColor = '#00d9ff';
                    ctx.shadowBlur = 10;
                    ctx.fillRect(screenX - 2, screenY - 2, this.width + 4, this.height + 4);
                    ctx.shadowBlur = 0;
                }
                if (this.speedBoostTime > 0) {
                    ctx.fillStyle = 'rgba(0, 255, 136, 0.3)';
                    ctx.shadowColor = '#00ff88';
                    ctx.shadowBlur = 10;
                    ctx.fillRect(screenX - 2, screenY - 2, this.width + 4, this.height + 4);
                    ctx.shadowBlur = 0;
                }

                // Corpo do jogador (cor baseada no número do jogador)
                ctx.fillStyle = this.color;
                ctx.fillRect(screenX, screenY, this.width, this.height);

                // Olhos
                ctx.fillStyle = '#ffffff';
                ctx.fillRect(screenX + 6, screenY + 8, 4, 4);
                ctx.fillRect(screenX + 14, screenY + 8, 4, 4);

                // Pupilas
                ctx.fillStyle = '#000000';
                ctx.fillRect(screenX + 8, screenY + 9, 2, 2);
                ctx.fillRect(screenX + 16, screenY + 9, 2, 2);

                // Boca - oval quando pulando/caindo
                ctx.fillStyle = '#000000';
                if (!this.grounded || Math.abs(this.vy) > 0.5) {
                    // Boca oval (aberta) - usando ellipse
                    ctx.beginPath();
                    ctx.ellipse(
                        screenX + 12,  // centro X
                        screenY + 20,  // centro Y
                        4,             // raio X
                        6,             // raio Y (maior = mais oval)
                        0, 0, Math.PI * 2
                    );
                    ctx.fill();
                } else {
                    // Boca normal (linha)
                    ctx.fillRect(screenX + 8, screenY + 18, 8, 2);
                }
            }
        }

        // ============================================
        // ENEMY
        // ============================================
        class Enemy {
            constructor(x, y, platformWidth, platformY) {
                this.x = x;
                this.y = y;
                this.width = CONFIG.ENEMY_SIZE;
                this.height = CONFIG.ENEMY_SIZE;
                this.vx = 1.5;
                this.vy = 0;
                this.platformX = x;
                this.platformWidth = platformWidth;
                this.platformY = platformY; // Guardar Y da plataforma
                this.alive = true;
                this.grounded = false;
            }

            update() {
                if (!this.alive) return;

                // Detectar borda antes de cair (edge detection)
                const checkDistance = 5; // pixels à frente para verificar
                const futureX = this.vx > 0 ? this.x + this.width + checkDistance : this.x - checkDistance;
                const futureY = this.y + this.height + 5; // Um pouco abaixo dos pés

                // Verificar se há chão à frente
                let hasGroundAhead = false;
                const startChunk = Math.floor((futureX - 50) / (CONFIG.CHUNK_WIDTH * CONFIG.TILE_SIZE));
                const endChunk = Math.floor((futureX + 50) / (CONFIG.CHUNK_WIDTH * CONFIG.TILE_SIZE));

                for (let chunkIdx = startChunk; chunkIdx <= endChunk; chunkIdx++) {
                    const chunk = game.chunks.get(chunkIdx);
                    if (!chunk) continue;

                    for (let platform of chunk.platforms) {
                        // Verificar se há plataforma à frente e abaixo dos pés
                        if (futureX > platform.x &&
                            futureX < platform.x + platform.width &&
                            futureY > platform.y - 10 &&
                            futureY < platform.y + platform.height) {
                            hasGroundAhead = true;
                            break;
                        }
                    }
                    if (hasGroundAhead) break;
                }

                // Virar se não houver chão à frente (evitar cair)
                if (!hasGroundAhead) {
                    this.vx *= -1;
                }

                // Movimento horizontal
                this.x += this.vx;

                // Patrulha na plataforma (inverter direção nas bordas)
                if (this.x <= this.platformX || this.x + this.width >= this.platformX + this.platformWidth) {
                    this.vx *= -1;
                    this.x = Math.max(this.platformX, Math.min(this.x, this.platformX + this.platformWidth - this.width));
                }

                // Gravidade
                this.vy += CONFIG.GRAVITY;
                this.y += this.vy;

                // Colisão com plataformas
                this.grounded = false;
                this.handlePlatformCollisions();

                // Limitar vy
                if (this.vy > 10) this.vy = 10;

                // Remover se cair do mundo
                if (this.y > game.height + 100) {
                    this.alive = false;
                }

                // Colisão com Player 1
                if (this.intersects(game.player)) {
                    // Detectar stomp (jogador caindo sobre o inimigo)
                    if (game.player.vy > CONFIG.STOMP_THRESHOLD &&
                        game.player.y + game.player.height < this.y + this.height * 0.5) {
                        this.alive = false;
                        game.player.vy = CONFIG.JUMP_STRENGTH * 0.5; // Mini bounce

                        // Adicionar pontos por derrotar inimigo
                        game.player.score += 50;
                        game.stats.enemiesDefeated++;
                        createFloatingText('+50', this.x + this.width / 2, this.y, '#ffff00');

                        createParticles(this.x + this.width / 2, this.y + this.height / 2, '#ff6b6b', 8);
                    } else {
                        // Jogador toma dano
                        game.player.takeDamage();
                    }
                }

                // Colisão com Player 2 (se existir)
                if (game.player2 && this.alive && this.intersects(game.player2)) {
                    // Detectar stomp (jogador caindo sobre o inimigo)
                    if (game.player2.vy > CONFIG.STOMP_THRESHOLD &&
                        game.player2.y + game.player2.height < this.y + this.height * 0.5) {
                        this.alive = false;
                        game.player2.vy = CONFIG.JUMP_STRENGTH * 0.5; // Mini bounce

                        // Adicionar pontos por derrotar inimigo
                        game.player2.score += 50;
                        game.stats.enemiesDefeated++;
                        createFloatingText('+50', this.x + this.width / 2, this.y, '#ffff00');

                        createParticles(this.x + this.width / 2, this.y + this.height / 2, '#ff6b6b', 8);
                    } else {
                        // Jogador toma dano
                        game.player2.takeDamage();
                    }
                }

            }

            handlePlatformCollisions() {
                const startChunk = Math.floor((this.x - 200) / (CONFIG.CHUNK_WIDTH * CONFIG.TILE_SIZE));
                const endChunk = Math.floor((this.x + 200) / (CONFIG.CHUNK_WIDTH * CONFIG.TILE_SIZE));

                for (let chunkIdx = startChunk; chunkIdx <= endChunk; chunkIdx++) {
                    const chunk = game.chunks.get(chunkIdx);
                    if (!chunk) continue;

                    chunk.platforms.forEach(platform => {
                        if (this.intersectsPlatform(platform)) {
                            const overlapLeft = (this.x + this.width) - platform.x;
                            const overlapRight = (platform.x + platform.width) - this.x;
                            const overlapTop = (this.y + this.height) - platform.y;
                            const overlapBottom = (platform.y + platform.height) - this.y;

                            const minOverlap = Math.min(overlapLeft, overlapRight, overlapTop, overlapBottom);

                            // Colisão de cima (pousar na plataforma)
                            if (minOverlap === overlapTop && this.vy >= 0) {
                                this.y = platform.y - this.height;
                                this.vy = 0;
                                this.grounded = true;
                            }
                        }
                    });
                }
            }

            intersectsPlatform(platform) {
                return this.x < platform.x + platform.width &&
                       this.x + this.width > platform.x &&
                       this.y < platform.y + platform.height &&
                       this.y + this.height > platform.y;
            }

            intersects(player) {
                return this.x < player.x + player.width &&
                       this.x + this.width > player.x &&
                       this.y < player.y + player.height &&
                       this.y + this.height > player.y;
            }

            draw(ctx) {
                if (!this.alive) return;

                const screenX = this.x - game.camera.x;
                const screenY = this.y - game.camera.y;

                // Corpo do inimigo (vermelho)
                ctx.fillStyle = '#ff6b6b';
                ctx.fillRect(screenX, screenY, this.width, this.height);

                // Olhos
                ctx.fillStyle = '#ffffff';
                ctx.fillRect(screenX + 6, screenY + 8, 4, 6);
                ctx.fillRect(screenX + 18, screenY + 8, 4, 6);

                // Pupilas
                ctx.fillStyle = '#000000';
                ctx.fillRect(screenX + 8, screenY + 10, 2, 2);
                ctx.fillRect(screenX + 20, screenY + 10, 2, 2);

                // Dentes
                ctx.fillStyle = '#ffffff';
                for (let i = 0; i < 4; i++) {
                    ctx.fillRect(screenX + 6 + i * 4, screenY + 20, 3, 4);
                }
            }
        }

        // ============================================
        // COIN
        // ============================================
        class Coin {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.width = CONFIG.COIN_SIZE;
                this.height = CONFIG.COIN_SIZE;
                this.collected = false;
                this.rotation = 0;
            }

            update() {
                if (this.collected) return;

                this.rotation += 0.05;

                // Colisão com Player 1
                if (this.intersects(game.player)) {
                    this.collected = true;
                    game.player.score += 10;
                    game.stats.coinsCollected++;
                    createFloatingText('+10', this.x + this.width / 2, this.y, '#ffd700');
                    createParticles(this.x + this.width / 2, this.y + this.height / 2, '#ffd700', 6);
                }

                // Colisão com Player 2 (se existir)
                if (game.player2 && !this.collected && this.intersects(game.player2)) {
                    this.collected = true;
                    game.player2.score += 10;
                    game.stats.coinsCollected++;
                    createFloatingText('+10', this.x + this.width / 2, this.y, '#ffd700');
                    createParticles(this.x + this.width / 2, this.y + this.height / 2, '#ffd700', 6);
                }
            }

            intersects(player) {
                return this.x < player.x + player.width &&
                       this.x + this.width > player.x &&
                       this.y < player.y + player.height &&
                       this.y + this.height > player.y;
            }

            draw(ctx) {
                if (this.collected) return;

                const screenX = this.x - game.camera.x + this.width / 2;
                const screenY = this.y - game.camera.y + this.height / 2;

                ctx.save();
                ctx.translate(screenX, screenY);
                ctx.rotate(this.rotation);

                // Moeda dourada
                ctx.fillStyle = '#ffd700';
                ctx.fillRect(-this.width / 2, -this.height / 2, this.width, this.height);

                // Brilho
                ctx.fillStyle = '#ffed4e';
                ctx.fillRect(-this.width / 3, -this.height / 3, this.width / 1.5, this.height / 1.5);

                ctx.restore();
            }
        }

        // ============================================
        // POWER-UP
        // ============================================
        class PowerUp {
            constructor(x, y, type) {
                this.x = x;
                this.y = y;
                this.width = 20;
                this.height = 20;
                this.type = type; // 'jump' ou 'speed'
                this.collected = false;
                this.rotation = 0;
                this.pulseTime = 0;
            }

            update() {
                if (this.collected) return;

                this.rotation += 0.03;
                this.pulseTime += 0.1;

                // Colisão com Player 1
                if (this.intersects(game.player)) {
                    this.collected = true;
                    this.applyEffect(game.player);

                    // Adicionar pontos por coletar power-up
                    game.player.score += 25;
                    game.stats.powerupsCollected++;

                    const color = this.type === 'jump' ? '#00d9ff' : '#00ff88';
                    createFloatingText('+25', this.x + this.width / 2, this.y, color);
                    createParticles(this.x + this.width / 2, this.y + this.height / 2, color, 12);
                }

                // Colisão com Player 2 (se existir)
                if (game.player2 && !this.collected && this.intersects(game.player2)) {
                    this.collected = true;
                    this.applyEffect(game.player2);

                    // Adicionar pontos por coletar power-up
                    game.player2.score += 25;
                    game.stats.powerupsCollected++;

                    const color = this.type === 'jump' ? '#00d9ff' : '#00ff88';
                    createFloatingText('+25', this.x + this.width / 2, this.y, color);
                    createParticles(this.x + this.width / 2, this.y + this.height / 2, color, 12);
                }
            }

            applyEffect(player) {
                if (this.type === 'jump') {
                    // Aumentar força do pulo por 10 segundos
                    player.jumpBoost = 1.4; // 40% mais forte
                    player.jumpBoostTime = 600; // 10 segundos a 60fps
                } else if (this.type === 'speed') {
                    // Aumentar velocidade por 10 segundos
                    player.speedBoost = 1.5; // 50% mais rápido
                    player.speedBoostTime = 600; // 10 segundos a 60fps
                }
            }

            intersects(player) {
                return this.x < player.x + player.width &&
                       this.x + this.width > player.x &&
                       this.y < player.y + player.height &&
                       this.y + this.height > player.y;
            }

            draw(ctx) {
                if (this.collected) return;

                const screenX = this.x - game.camera.x + this.width / 2;
                const screenY = this.y - game.camera.y + this.height / 2;

                // Efeito de pulso
                const pulse = 1 + Math.sin(this.pulseTime) * 0.2;
                const size = this.width * pulse;

                ctx.save();
                ctx.translate(screenX, screenY);
                ctx.rotate(this.rotation);

                // Cor baseada no tipo
                if (this.type === 'jump') {
                    // Azul brilhante
                    ctx.fillStyle = '#00d9ff';
                    ctx.shadowColor = '#00d9ff';
                    ctx.shadowBlur = 15;
                } else {
                    // Verde brilhante
                    ctx.fillStyle = '#00ff88';
                    ctx.shadowColor = '#00ff88';
                    ctx.shadowBlur = 15;
                }

                // Desenhar círculo
                ctx.beginPath();
                ctx.arc(0, 0, size / 2, 0, Math.PI * 2);
                ctx.fill();

                // Anel interno
                ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
                ctx.beginPath();
                ctx.arc(0, 0, size / 3, 0, Math.PI * 2);
                ctx.fill();

                ctx.restore();
            }
        }

        // ============================================
        // FLOATING TEXT (Feedback de Pontos)
        // ============================================
        class FloatingText {
            constructor(text, x, y, color) {
                this.text = text;
                this.x = x;
                this.y = y;
                this.vy = -2; // Sobe
                this.life = 60; // 1 segundo a 60fps
                this.maxLife = 60;
                this.color = color;
            }

            update() {
                this.y += this.vy;
                this.life--;
            }

            draw(ctx) {
                const screenX = this.x - game.camera.x;
                const screenY = this.y - game.camera.y;
                const alpha = this.life / this.maxLife;

                ctx.save();
                ctx.font = 'bold 20px monospace';
                ctx.fillStyle = this.color;
                ctx.strokeStyle = '#000000';
                ctx.lineWidth = 3;
                ctx.globalAlpha = alpha;

                // Contorno
                ctx.strokeText(this.text, screenX, screenY);
                // Texto
                ctx.fillText(this.text, screenX, screenY);

                ctx.restore();
            }
        }

        // Helper para criar textos flutuantes
        function createFloatingText(text, x, y, color) {
            game.floatingTexts.push(new FloatingText(text, x, y, color));
        }

        // ============================================
        // PARTICLE
        // ============================================
        class Particle {
            constructor(x, y, color) {
                this.x = x;
                this.y = y;
                this.vx = (Math.random() - 0.5) * 6;
                this.vy = (Math.random() - 0.5) * 6 - 2;
                this.life = 30;
                this.maxLife = 30;
                this.color = color;
                this.size = Math.random() * 4 + 2;
            }

            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.vy += 0.3;
                this.life--;
            }

            draw(ctx) {
                const screenX = this.x - game.camera.x;
                const screenY = this.y - game.camera.y;
                const alpha = this.life / this.maxLife;

                ctx.fillStyle = this.color;
                ctx.globalAlpha = alpha;
                ctx.fillRect(screenX, screenY, this.size, this.size);
                ctx.globalAlpha = 1;
            }
        }

        // ============================================
        // HELPERS DE COLISÃO (para geração de itens)
        // ============================================

        // Verifica se dois retângulos se sobrepõem (AABB collision)
        function checkOverlap(x1, y1, w1, h1, x2, y2, w2, h2, margin = 10) {
            return !(x1 + w1 + margin < x2 ||
                     x2 + w2 + margin < x1 ||
                     y1 + h1 + margin < y2 ||
                     y2 + h2 + margin < y1);
        }

        // Verifica se um item pode ser colocado sem colidir com existentes
        function canPlaceItem(newX, newY, newW, newH, existingItems) {
            for (let item of existingItems) {
                const itemW = item.width || item.size || CONFIG.COIN_SIZE;
                const itemH = item.height || item.size || CONFIG.COIN_SIZE;

                if (checkOverlap(newX, newY, newW, newH, item.x, item.y, itemW, itemH)) {
                    return false;
                }
            }
            return true;
        }

        // ============================================
        // CHUNK (Geração Procedural)
        // ============================================
        class Chunk {
            constructor(index, random) {
                this.index = index;
                this.x = index * CONFIG.CHUNK_WIDTH * CONFIG.TILE_SIZE;
                this.platforms = [];
                this.coins = [];
                this.enemies = [];
                this.powerups = [];

                this.generate(random);
            }

            generate(rng) {
                const tileSize = CONFIG.TILE_SIZE;
                const chunkWidth = CONFIG.CHUNK_WIDTH * tileSize;
                const startX = this.x;

                // Dificuldade baseada no índice do chunk
                const difficulty = Math.min(this.index / 10, 3);

                // Dificuldade progressiva para tamanho das plataformas
                // Reduz de 8 tiles até 1.5x o tamanho do jogador ao longo de 20 chunks
                const minPlatformSize = CONFIG.PLAYER_WIDTH * 1.5; // 36 pixels (1.5x jogador)
                const maxPlatformSize = tileSize * 8; // 256 pixels
                const progressionRate = Math.min(this.index / 20, 1); // 0 a 1 ao longo de 20 chunks (mais rápido!)

                // Interpolar entre max e min baseado na progressão
                const currentMaxSize = maxPlatformSize - (maxPlatformSize - minPlatformSize) * progressionRate;
                const currentMinSize = Math.max(minPlatformSize, tileSize * 3 - (tileSize * 1.5 * progressionRate));

                // Gerar terreno base
                let lastHeight = game.height - 150 - rng.range(-50, 50);
                let x = startX;

                while (x < startX + chunkWidth) {
                    // Tamanho do próximo platô (progressivamente menor)
                    const plateauWidth = Math.max(
                        minPlatformSize,
                        rng.range(currentMinSize, currentMaxSize)
                    );

                    // Criar plataforma
                    const platform = {
                        x: x,
                        y: lastHeight,
                        width: plateauWidth,
                        height: tileSize * 3,
                        type: 'ground'
                    };

                    // Verificar se não colide com a plataforma anterior (casos extremos de altura)
                    let canPlace = true;
                    if (this.platforms.length > 0) {
                        const lastPlatform = this.platforms[this.platforms.length - 1];
                        // Apenas verificar se estão muito próximas horizontalmente
                        if (Math.abs(platform.x - lastPlatform.x) < plateauWidth + lastPlatform.width) {
                            if (checkOverlap(
                                platform.x, platform.y, platform.width, platform.height,
                                lastPlatform.x, lastPlatform.y, lastPlatform.width, lastPlatform.height,
                                0 // Sem margem, apenas detectar overlap real
                            )) {
                                // Se colidir, ajustar altura para não sobrepor
                                if (lastHeight < lastPlatform.y) {
                                    lastHeight = lastPlatform.y - tileSize * 4; // Forçar ficar acima
                                } else {
                                    lastHeight = lastPlatform.y + lastPlatform.height + tileSize; // Forçar ficar abaixo
                                }
                                platform.y = lastHeight;
                            }
                        }
                    }

                    this.platforms.push(platform);

                    // Array para rastrear itens nesta plataforma (evitar colisões)
                    const platformItems = [];

                    // Adicionar inimigo primeiro (começa no chunk 1, 50% de chance)
                    let hasEnemy = false;
                    if (rng.next() > 0.5 && this.index >= 1 && plateauWidth > CONFIG.ENEMY_SIZE * 2) {
                        const enemyX = x + plateauWidth / 2 - CONFIG.ENEMY_SIZE / 2;
                        const enemyY = lastHeight - CONFIG.ENEMY_SIZE;
                        const enemy = new Enemy(enemyX, enemyY, plateauWidth, lastHeight);
                        this.enemies.push(enemy);
                        // Adicionar ao rastreador de colisões
                        platformItems.push({
                            x: enemyX,
                            y: enemyY,
                            width: CONFIG.ENEMY_SIZE,
                            height: CONFIG.ENEMY_SIZE
                        });
                        hasEnemy = true;
                    }

                    // Adicionar moedas na plataforma (evitando inimigo)
                    if (rng.next() > 0.5) {
                        const numCoins = rng.int(2, 5);
                        let coinsPlaced = 0;

                        // Tentar colocar moedas
                        for (let i = 0; i < numCoins && coinsPlaced < numCoins; i++) {
                            // Se tem inimigo, evitar centro (usar laterais)
                            let coinX;
                            if (hasEnemy) {
                                // Dividir plataforma em zonas laterais
                                const zone = i % 2; // Alterna entre esquerda e direita
                                if (zone === 0) {
                                    // Zona esquerda (0-40%)
                                    coinX = x + rng.range(CONFIG.COIN_SIZE, plateauWidth * 0.4);
                                } else {
                                    // Zona direita (60-100%)
                                    coinX = x + rng.range(plateauWidth * 0.6, plateauWidth - CONFIG.COIN_SIZE);
                                }
                            } else {
                                // Sem inimigo, distribuir uniformemente
                                coinX = x + (i + 1) * (plateauWidth / (numCoins + 1));
                            }

                            const coinY = lastHeight - tileSize * 2;

                            // Verificar se não colide com outros itens
                            if (canPlaceItem(coinX, coinY, CONFIG.COIN_SIZE, CONFIG.COIN_SIZE, platformItems)) {
                                const coin = new Coin(coinX, coinY);
                                this.coins.push(coin);
                                platformItems.push({
                                    x: coinX,
                                    y: coinY,
                                    width: CONFIG.COIN_SIZE,
                                    height: CONFIG.COIN_SIZE
                                });
                                coinsPlaced++;
                            }
                        }
                    }

                    x += plateauWidth;

                    // Gap entre plataformas
                    const gap = rng.range(
                        tileSize * (2 + difficulty * 0.5),
                        tileSize * (4 + difficulty)
                    );
                    x += gap;

                    // Próxima altura (limitada para ser alcançável)
                    const maxHeightDiff = tileSize * 2; // Diferença máxima de altura
                    lastHeight += rng.range(-maxHeightDiff, maxHeightDiff);

                    // Limites de altura
                    lastHeight = Math.max(game.height / 3, Math.min(game.height - 100, lastHeight));
                }

                // Adicionar algumas plataformas flutuantes (sem sobreposição)
                if (rng.next() > 0.6) {
                    const numFloating = rng.int(1, 3);
                    let floatingAttempts = 0;
                    let floatingPlaced = 0;

                    while (floatingPlaced < numFloating && floatingAttempts < numFloating * 5) {
                        const floatingX = startX + rng.range(tileSize * 5, chunkWidth - tileSize * 5);
                        const floatingY = game.height * 0.3 + rng.range(0, game.height * 0.3);
                        const floatingWidth = tileSize * rng.int(3, 6);

                        const newFloating = {
                            x: floatingX,
                            y: floatingY,
                            width: floatingWidth,
                            height: tileSize,
                            type: 'floating'
                        };

                        // Verificar se não colide com outras plataformas
                        let collides = false;
                        for (let platform of this.platforms) {
                            // Adicionar margem de segurança de 20px
                            if (checkOverlap(
                                newFloating.x, newFloating.y, newFloating.width, newFloating.height,
                                platform.x, platform.y, platform.width, platform.height,
                                20
                            )) {
                                collides = true;
                                break;
                            }
                        }

                        if (!collides) {
                            this.platforms.push(newFloating);
                            floatingPlaced++;

                            // Adicionar apenas 1 item por plataforma flutuante
                            // Escolher aleatoriamente: moeda OU nada (50% de chance)
                            if (rng.next() > 0.5) {
                                const itemX = floatingX + floatingWidth / 2 - CONFIG.COIN_SIZE / 2;
                                const itemY = floatingY - tileSize * 1.5;

                                // Sempre moeda em plataforma flutuante
                                this.coins.push(new Coin(itemX, itemY));
                            }
                        }

                        floatingAttempts++;
                    }
                }

                // Adicionar power-ups raramente (15% de chance por chunk)
                if (rng.next() > 0.85 && this.index > 0) {
                    // Criar lista de todos os itens já colocados (para verificar colisões)
                    const allItems = [];

                    // Adicionar todas as moedas
                    this.coins.forEach(coin => {
                        allItems.push({
                            x: coin.x,
                            y: coin.y,
                            width: CONFIG.COIN_SIZE,
                            height: CONFIG.COIN_SIZE
                        });
                    });

                    // Adicionar todos os inimigos
                    this.enemies.forEach(enemy => {
                        allItems.push({
                            x: enemy.x,
                            y: enemy.y,
                            width: CONFIG.ENEMY_SIZE,
                            height: CONFIG.ENEMY_SIZE
                        });
                    });

                    // Tentar encontrar uma plataforma válida (sem inimigos)
                    if (this.platforms.length > 0) {
                        let attempts = 0;
                        let placed = false;

                        while (attempts < 5 && !placed) {
                            const platform = this.platforms[rng.int(0, this.platforms.length - 1)];

                            // Escolher tipo de power-up aleatoriamente
                            const type = rng.next() > 0.5 ? 'jump' : 'speed';
                            const powerupX = platform.x + platform.width / 2 - 10;
                            const powerupY = platform.y - 40;

                            // Verificar se não colide com outros itens
                            if (canPlaceItem(powerupX, powerupY, 20, 20, allItems)) {
                                this.powerups.push(new PowerUp(powerupX, powerupY, type));
                                placed = true;
                            }

                            attempts++;
                        }
                    }
                }
            }

            draw(ctx) {
                this.platforms.forEach(platform => {
                    const screenX = platform.x - game.camera.x;
                    const screenY = platform.y - game.camera.y;

                    // Cor baseada no tipo
                    if (platform.type === 'floating') {
                        ctx.fillStyle = '#8b5cf6';
                    } else {
                        ctx.fillStyle = '#2ecc71';
                    }

                    ctx.fillRect(screenX, screenY, platform.width, platform.height);

                    // Borda superior mais clara
                    ctx.fillStyle = platform.type === 'floating' ? '#a78bfa' : '#52d681';
                    ctx.fillRect(screenX, screenY, platform.width, 4);
                });
            }
        }

        // ============================================
        // GERAÇÃO E GESTÃO DE CHUNKS
        // ============================================
        function updateChunks() {
            // No modo 2 jogadores, considerar o jogador mais à direita
            let referenceX = game.player.x;
            if (game.twoPlayerMode && game.player2 && game.player2.lives > 0) {
                referenceX = Math.max(game.player.x, game.player2.x);
            }

            const playerChunk = Math.floor(referenceX / (CONFIG.CHUNK_WIDTH * CONFIG.TILE_SIZE));

            // Gerar chunks à frente e atrás
            for (let i = playerChunk - CONFIG.VIEW_DISTANCE; i <= playerChunk + CONFIG.VIEW_DISTANCE; i++) {
                if (!game.chunks.has(i)) {
                    // Criar seed única para este chunk baseada na seed global
                    const chunkRandom = new Random(game.seed + i * 1000);
                    const chunk = new Chunk(i, chunkRandom);
                    game.chunks.set(i, chunk);

                    // Adicionar entidades do chunk às listas globais
                    game.coins.push(...chunk.coins);
                    game.enemies.push(...chunk.enemies);
                    game.powerups.push(...chunk.powerups);
                }
            }

            // Remover chunks muito distantes (culling)
            const chunksToRemove = [];
            game.chunks.forEach((chunk, index) => {
                if (Math.abs(index - playerChunk) > CONFIG.VIEW_DISTANCE + 2) {
                    chunksToRemove.push(index);
                }
            });

            chunksToRemove.forEach(index => {
                const chunk = game.chunks.get(index);
                // Remover entidades do chunk
                game.coins = game.coins.filter(c => !chunk.coins.includes(c));
                game.enemies = game.enemies.filter(e => !chunk.enemies.includes(e));
                game.powerups = game.powerups.filter(p => !chunk.powerups.includes(p));
                game.chunks.delete(index);
            });
        }

        // ============================================
        // CAMERA
        // ============================================
        function updateCamera() {
            // Modo 2 jogadores: seguir o jogador mais à direita
            if (game.twoPlayerMode && game.player2) {
                const rightmostX = Math.max(game.player.x, game.player2.x);
                game.camera.targetX = rightmostX - game.width / 3;
            } else {
                // Modo 1 jogador: seguir o jogador normalmente
                game.camera.targetX = game.player.x - game.width / 3;
            }

            game.camera.x += (game.camera.targetX - game.camera.x) * 0.1;

            // Limitar câmera para não mostrar área negativa
            if (game.camera.x < 0) game.camera.x = 0;

            // Camera Y fixa
            game.camera.y = 0;
        }

        // ============================================
        // PARALLAX BACKGROUND
        // ============================================
        function drawBackground(ctx) {
            // Camada 1 - Mais distante (montanhas)
            const parallax1 = game.camera.x * 0.2;
            ctx.fillStyle = '#2c3e50';
            for (let i = -1; i < 6; i++) {
                const x = i * 300 - (parallax1 % 300);
                ctx.beginPath();
                ctx.moveTo(x, game.height);
                ctx.lineTo(x + 150, game.height - 200);
                ctx.lineTo(x + 300, game.height);
                ctx.fill();
            }

            // Camada 2 - Meio (colinas)
            const parallax2 = game.camera.x * 0.4;
            ctx.fillStyle = '#34495e';
            for (let i = -1; i < 8; i++) {
                const x = i * 200 - (parallax2 % 200);
                ctx.beginPath();
                ctx.moveTo(x, game.height);
                ctx.lineTo(x + 100, game.height - 120);
                ctx.lineTo(x + 200, game.height);
                ctx.fill();
            }

            // Camada 3 - Frente (árvores)
            const parallax3 = game.camera.x * 0.7;
            ctx.fillStyle = '#27ae60';
            for (let i = -1; i < 15; i++) {
                const x = i * 100 - (parallax3 % 100);
                ctx.fillRect(x + 40, game.height - 80, 20, 80);
                ctx.fillStyle = '#229954';
                ctx.beginPath();
                ctx.arc(x + 50, game.height - 80, 30, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#27ae60';
            }
        }

        // ============================================
        // PARTICLES
        // ============================================
        function createParticles(x, y, color, count) {
            for (let i = 0; i < count; i++) {
                game.particles.push(new Particle(x, y, color));
            }
        }

        // ============================================
        // GAME LOOP
        // ============================================
        function gameLoop(currentTime) {
            requestAnimationFrame(gameLoop);

            if (game.state !== 'playing') return;

            // Delta time
            game.deltaTime = currentTime - game.lastTime;
            game.lastTime = currentTime;

            // Update
            updateChunks();
            game.player.update();
            if (game.twoPlayerMode && game.player2) {
                game.player2.update();
            }
            game.coins.forEach(coin => coin.update());
            game.enemies.forEach(enemy => enemy.update());
            game.powerups.forEach(powerup => powerup.update());
            game.particles.forEach(particle => particle.update());
            game.floatingTexts.forEach(text => text.update());

            // Remover partículas e textos mortos
            game.particles = game.particles.filter(p => p.life > 0);
            game.floatingTexts = game.floatingTexts.filter(t => t.life > 0);

            // Atualizar HUD
            document.getElementById('p1-score').textContent = game.player.score;
            if (game.twoPlayerMode && game.player2) {
                document.getElementById('p2-score').textContent = game.player2.score;
            }
            document.getElementById('distance').textContent = game.distance;

            updateCamera();

            // Draw
            const ctx = game.ctx;

            // Background
            ctx.fillStyle = '#87ceeb';
            ctx.fillRect(0, 0, game.width, game.height);

            drawBackground(ctx);

            // Chunks (terreno)
            game.chunks.forEach(chunk => chunk.draw(ctx));

            // Entities
            game.coins.forEach(coin => coin.draw(ctx));
            game.enemies.forEach(enemy => enemy.draw(ctx));
            game.powerups.forEach(powerup => powerup.draw(ctx));
            game.particles.forEach(particle => particle.draw(ctx));

            // Players
            game.player.draw(ctx);
            if (game.twoPlayerMode && game.player2) {
                game.player2.draw(ctx);
            }

            // Floating texts (por cima de tudo)
            game.floatingTexts.forEach(text => text.draw(ctx));

            // Dev Mode UI (por cima de absolutamente tudo)
            drawDevModeUI(ctx);

            // Debug info (desativado)
            // ctx.fillStyle = 'white';
            // ctx.font = '16px monospace';
            // ctx.fillText(`Chunks: ${game.chunks.size}`, 10, game.height - 60);
        }

        // ============================================
        // MENU E CONTROLES
        // ============================================
        document.getElementById('start1PBtn').addEventListener('click', () => startGame(false));
        document.getElementById('start2PBtn').addEventListener('click', () => startGame(true));
        document.getElementById('instructionsBtn').addEventListener('click', () => {
            const instructions = document.getElementById('instructions');
            instructions.classList.toggle('hidden');
        });

        function startGame(twoPlayerMode = false) {
            // Gerar seed aleatório
            game.seed = Math.floor(Math.random() * 1000000);
            console.log('Seed:', game.seed);

            // Definir modo de jogo
            game.twoPlayerMode = twoPlayerMode;

            // Inicializar random
            game.random = new Random(game.seed);

            // Esconder menu
            document.getElementById('menu').classList.add('hidden');
            document.getElementById('hud').classList.remove('hidden');

            // Inicializar jogo
            game.chunks.clear();
            game.coins = [];
            game.enemies = [];
            game.powerups = [];
            game.particles = [];
            game.floatingTexts = [];
            game.score = 0;
            game.lives = 3;
            game.distance = 0;
            game.difficulty = 0;
            game.stats = {
                coinsCollected: 0,
                enemiesDefeated: 0,
                powerupsCollected: 0,
                lastDistance: 0
            };

            // Criar jogador(es)
            game.player = new Player(100, 100, 1);

            if (twoPlayerMode) {
                game.player2 = new Player(150, 100, 2);
                document.getElementById('p2-hud').style.display = 'block';
                console.log('Modo 2 jogadores ativado!');
            } else {
                game.player2 = null;
                document.getElementById('p2-hud').style.display = 'none';
            }

            // Criar plataforma inicial sob os jogadores (chunk -1)
            const startChunk = {
                index: -1,
                x: -CONFIG.CHUNK_WIDTH * CONFIG.TILE_SIZE,
                platforms: [{
                    x: 0,
                    y: game.height - 100,
                    width: 300,
                    height: CONFIG.TILE_SIZE * 3,
                    type: 'ground'
                }],
                coins: [],
                enemies: [],
                powerups: [],
                draw: function(ctx) {
                    this.platforms.forEach(platform => {
                        const screenX = platform.x - game.camera.x;
                        const screenY = platform.y - game.camera.y;
                        ctx.fillStyle = '#2ecc71';
                        ctx.fillRect(screenX, screenY, platform.width, platform.height);
                    });
                }
            };
            game.chunks.set(-1, startChunk);

            // Atualizar HUD
            document.getElementById('p1-score').textContent = game.player.score;
            document.getElementById('p1-lives').textContent = game.player.lives;
            if (twoPlayerMode) {
                document.getElementById('p2-score').textContent = game.player2.score;
                document.getElementById('p2-lives').textContent = game.player2.lives;
            }
            document.getElementById('distance').textContent = game.distance;

            // Iniciar loop
            game.state = 'playing';
            game.lastTime = performance.now();
        }

        function showGameOver() {
            game.state = 'gameover';

            const menu = document.getElementById('menu');

            if (game.twoPlayerMode) {
                // Modo 2 jogadores: mostrar pontuação individual e total
                const p1Score = game.player.score;
                const p2Score = game.player2.score;
                const totalScore = p1Score + p2Score;

                // Calcular pontos de cada categoria (estatísticas globais)
                const coinPoints = game.stats.coinsCollected * 10;
                const enemyPoints = game.stats.enemiesDefeated * 50;
                const powerupPoints = game.stats.powerupsCollected * 25;
                const distancePoints = game.distance;

                menu.innerHTML = `
                    <h1>GAME OVER</h1>
                    <div style="text-align: left; display: inline-block; margin: 20px 0;">
                        <p style="font-size: 18px; margin: 10px 0;"><strong>📊 Breakdown da Pontuação:</strong></p>
                        <p style="font-size: 16px; margin: 8px 0;">💰 Moedas: ${game.stats.coinsCollected} × 10 = ${coinPoints} pts</p>
                        <p style="font-size: 16px; margin: 8px 0;">👹 Inimigos: ${game.stats.enemiesDefeated} × 50 = ${enemyPoints} pts</p>
                        <p style="font-size: 16px; margin: 8px 0;">⚡ Power-ups: ${game.stats.powerupsCollected} × 25 = ${powerupPoints} pts</p>
                        <p style="font-size: 16px; margin: 8px 0;">📏 Distância: ${game.distance}m = ${distancePoints} pts</p>
                        <hr style="margin: 15px 0; border-color: #00ffff;">
                        <p style="font-size: 20px; margin: 10px 0; color: #00d9ff;"><strong>🎮 Player 1: ${p1Score} pontos</strong></p>
                        <p style="font-size: 20px; margin: 10px 0; color: #ff6b6b;"><strong>🎮 Player 2: ${p2Score} pontos</strong></p>
                        <hr style="margin: 15px 0; border-color: #00ffff;">
                        <p style="font-size: 24px; margin: 10px 0; color: #00ffff;"><strong>🏆 TOTAL: ${totalScore} pontos</strong></p>
                    </div>
                    <button onclick="location.reload()">Jogar Novamente</button>
                `;
            } else {
                // Modo 1 jogador: mostrar pontuação única
                const coinPoints = game.stats.coinsCollected * 10;
                const enemyPoints = game.stats.enemiesDefeated * 50;
                const powerupPoints = game.stats.powerupsCollected * 25;
                const distancePoints = game.distance;

                menu.innerHTML = `
                    <h1>GAME OVER</h1>
                    <div style="text-align: left; display: inline-block; margin: 20px 0;">
                        <p style="font-size: 18px; margin: 10px 0;"><strong>📊 Breakdown da Pontuação:</strong></p>
                        <p style="font-size: 16px; margin: 8px 0;">💰 Moedas: ${game.stats.coinsCollected} × 10 = ${coinPoints} pts</p>
                        <p style="font-size: 16px; margin: 8px 0;">👹 Inimigos: ${game.stats.enemiesDefeated} × 50 = ${enemyPoints} pts</p>
                        <p style="font-size: 16px; margin: 8px 0;">⚡ Power-ups: ${game.stats.powerupsCollected} × 25 = ${powerupPoints} pts</p>
                        <p style="font-size: 16px; margin: 8px 0;">📏 Distância: ${game.distance}m = ${distancePoints} pts</p>
                        <hr style="margin: 15px 0; border-color: #00ffff;">
                        <p style="font-size: 22px; margin: 10px 0; color: #00ffff;"><strong>🏆 TOTAL: ${game.player.score} pontos</strong></p>
                    </div>
                    <button onclick="location.reload()">Jogar Novamente</button>
                `;
            }

            menu.classList.remove('hidden');
            document.getElementById('hud').classList.add('hidden');
        }

        // ============================================
        // DEV MODE - Funções
        // ============================================

        function toggleDevMode() {
            game.devMode.enabled = !game.devMode.enabled;

            if (game.devMode.enabled) {
                console.log('🛠️ DEV MODE ATIVADO');
                // Ativar invencibilidade e noclip por padrão
                game.devMode.invincible = true;
                game.devMode.noclip = true;
                game.devMode.showHitboxes = false;
                game.devMode.showGrid = false;
            } else {
                console.log('DEV MODE DESATIVADO');
                game.devMode.noclip = false;
                game.devMode.invincible = false;
                game.devMode.gravityEnabled = true;
            }
        }

        function handleDevModeKeys(key) {
            if (!game.devMode.enabled) return;

            switch(key.toLowerCase()) {
                case 'h': // Toggle Hitboxes
                    game.devMode.showHitboxes = !game.devMode.showHitboxes;
                    console.log('Hitboxes:', game.devMode.showHitboxes ? 'ON' : 'OFF');
                    break;

                case 'g': // Toggle Gravity
                    game.devMode.gravityEnabled = !game.devMode.gravityEnabled;
                    console.log('Gravidade:', game.devMode.gravityEnabled ? 'ON' : 'OFF');
                    break;

                case 'f': // Toggle Noclip/Fly
                    game.devMode.noclip = !game.devMode.noclip;
                    console.log('Voo/Noclip:', game.devMode.noclip ? 'ON' : 'OFF');
                    break;

                case 'i': // Toggle Invincible
                    game.devMode.invincible = !game.devMode.invincible;
                    console.log('Invencível:', game.devMode.invincible ? 'ON' : 'OFF');
                    break;

                case 'm': // Teleport forward
                    game.player.x += 500;
                    console.log('Teleport +500px');
                    break;

                case 'r': // Reset position
                    game.player.x = 100;
                    game.player.y = 100;
                    console.log('Posição resetada');
                    break;

                case 'n': // Force generate next chunk
                    const nextChunk = Math.floor(game.player.x / (CONFIG.CHUNK_WIDTH * CONFIG.TILE_SIZE)) + 1;
                    if (!game.chunks.has(nextChunk)) {
                        const chunkRandom = new Random(game.seed + nextChunk * 1000);
                        const chunk = new Chunk(nextChunk, chunkRandom);
                        game.chunks.set(nextChunk, chunk);
                        game.coins.push(...chunk.coins);
                        game.enemies.push(...chunk.enemies);
                        game.powerups.push(...chunk.powerups);
                        console.log('Chunk', nextChunk, 'gerado manualmente');
                    }
                    break;

                case 'b': // Toggle grid
                    game.devMode.showGrid = !game.devMode.showGrid;
                    console.log('Grid:', game.devMode.showGrid ? 'ON' : 'OFF');
                    break;

                case '=':
                case '+': // Increase speed
                    game.devMode.flySpeed = Math.min(30, game.devMode.flySpeed + 2);
                    console.log('Velocidade de voo:', game.devMode.flySpeed);
                    break;

                case '-':
                case '_': // Decrease speed
                    game.devMode.flySpeed = Math.max(2, game.devMode.flySpeed - 2);
                    console.log('Velocidade de voo:', game.devMode.flySpeed);
                    break;
            }
        }

        function drawDevModeUI(ctx) {
            if (!game.devMode.enabled) return;

            // Painel de informações
            if (game.devMode.showInfo) {
                ctx.save();

                // Fundo do painel (aumentado para 330 de altura)
                ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                ctx.fillRect(10, 10, 300, 330);

                // Borda
                ctx.strokeStyle = '#00ffff';
                ctx.lineWidth = 2;
                ctx.strokeRect(10, 10, 300, 330);

                // Texto
                ctx.fillStyle = '#00ffff';
                ctx.font = 'bold 16px monospace';
                ctx.fillText('🛠️ DEV MODE ATIVO', 20, 35);

                ctx.strokeStyle = '#00ffff';
                ctx.beginPath();
                ctx.moveTo(20, 45);
                ctx.lineTo(290, 45);
                ctx.stroke();

                ctx.fillStyle = '#ffffff';
                ctx.font = '12px monospace';
                let y = 65;
                const lineHeight = 18;

                ctx.fillText(`Pos: (${Math.floor(game.player.x)}, ${Math.floor(game.player.y)})`, 20, y); y += lineHeight;
                ctx.fillText(`Vel: (${game.player.vx.toFixed(1)}, ${game.player.vy.toFixed(1)})`, 20, y); y += lineHeight;
                ctx.fillText(`Chunk: ${Math.floor(game.player.x / (CONFIG.CHUNK_WIDTH * CONFIG.TILE_SIZE))}`, 20, y); y += lineHeight;
                ctx.fillText(`Chunks Loaded: ${game.chunks.size}`, 20, y); y += lineHeight;
                ctx.fillText(`Enemies: ${game.enemies.filter(e => e.alive).length}/${game.enemies.length}`, 20, y); y += lineHeight;
                ctx.fillText(`Coins: ${game.coins.filter(c => !c.collected).length}/${game.coins.length}`, 20, y); y += lineHeight;
                ctx.fillText(`Powerups: ${game.powerups.filter(p => !p.collected).length}/${game.powerups.length}`, 20, y); y += lineHeight;

                y += 10;
                ctx.strokeStyle = '#555555';
                ctx.beginPath();
                ctx.moveTo(20, y - 5);
                ctx.lineTo(290, y - 5);
                ctx.stroke();

                ctx.fillStyle = game.devMode.noclip ? '#00ff00' : '#ff0000';
                ctx.fillText(`[F] Voo: ${game.devMode.noclip ? 'ON' : 'OFF'}`, 20, y); y += lineHeight;

                ctx.fillStyle = game.devMode.invincible ? '#00ff00' : '#ff0000';
                ctx.fillText(`[I] Invencível: ${game.devMode.invincible ? 'ON' : 'OFF'}`, 20, y); y += lineHeight;

                ctx.fillStyle = game.devMode.gravityEnabled ? '#00ff00' : '#ff0000';
                ctx.fillText(`[G] Gravidade: ${game.devMode.gravityEnabled ? 'ON' : 'OFF'}`, 20, y); y += lineHeight;

                ctx.fillStyle = game.devMode.showHitboxes ? '#00ff00' : '#ff0000';
                ctx.fillText(`[H] Hitboxes: ${game.devMode.showHitboxes ? 'ON' : 'OFF'}`, 20, y); y += lineHeight;

                ctx.fillStyle = game.devMode.showGrid ? '#00ff00' : '#ff0000';
                ctx.fillText(`[B] Grid: ${game.devMode.showGrid ? 'ON' : 'OFF'}`, 20, y); y += lineHeight;

                y += 10;
                ctx.fillStyle = '#ffff00';
                ctx.fillText(`[M] Teleport  [R] Reset`, 20, y); y += lineHeight;
                ctx.fillText(`[+/-] Speed (${game.devMode.flySpeed})`, 20, y); y += lineHeight;
                ctx.fillText(`[F3] Exit Dev Mode`, 20, y);

                ctx.restore();
            }

            // Desenhar grid
            if (game.devMode.showGrid) {
                ctx.save();
                ctx.strokeStyle = 'rgba(255, 255, 0, 0.2)';
                ctx.lineWidth = 1;

                // Grid vertical (chunks)
                const startChunk = Math.floor(game.camera.x / (CONFIG.CHUNK_WIDTH * CONFIG.TILE_SIZE));
                const endChunk = startChunk + 5;

                for (let i = startChunk; i <= endChunk; i++) {
                    const x = i * CONFIG.CHUNK_WIDTH * CONFIG.TILE_SIZE - game.camera.x;
                    ctx.beginPath();
                    ctx.moveTo(x, 0);
                    ctx.lineTo(x, game.height);
                    ctx.stroke();

                    // Número do chunk
                    ctx.fillStyle = 'rgba(255, 255, 0, 0.5)';
                    ctx.font = '20px monospace';
                    ctx.fillText(`Chunk ${i}`, x + 10, 30);
                }

                ctx.restore();
            }

            // Desenhar hitboxes
            if (game.devMode.showHitboxes) {
                ctx.save();
                ctx.lineWidth = 2;

                // Player hitbox
                ctx.strokeStyle = '#00ffff';
                ctx.strokeRect(
                    game.player.x - game.camera.x,
                    game.player.y - game.camera.y,
                    game.player.width,
                    game.player.height
                );

                // Enemies hitboxes
                game.enemies.filter(e => e.alive).forEach(enemy => {
                    ctx.strokeStyle = '#ff0000';
                    ctx.strokeRect(
                        enemy.x - game.camera.x,
                        enemy.y - game.camera.y,
                        enemy.width,
                        enemy.height
                    );
                });

                // Coins hitboxes
                game.coins.filter(c => !c.collected).forEach(coin => {
                    ctx.strokeStyle = '#ffff00';
                    ctx.strokeRect(
                        coin.x - game.camera.x,
                        coin.y - game.camera.y,
                        coin.width,
                        coin.height
                    );
                });

                // Powerups hitboxes
                game.powerups.filter(p => !p.collected).forEach(powerup => {
                    ctx.strokeStyle = '#00ff00';
                    ctx.strokeRect(
                        powerup.x - game.camera.x,
                        powerup.y - game.camera.y,
                        powerup.width,
                        powerup.height
                    );
                });

                // Platforms hitboxes
                game.chunks.forEach(chunk => {
                    chunk.platforms.forEach(platform => {
                        ctx.strokeStyle = '#ffffff';
                        ctx.globalAlpha = 0.3;
                        ctx.strokeRect(
                            platform.x - game.camera.x,
                            platform.y - game.camera.y,
                            platform.width,
                            platform.height
                        );
                    });
                });

                ctx.restore();
            }
        }

        // Controles de teclado
        document.addEventListener('keydown', (e) => {
            game.keys[e.key] = true;

            // Detectar F3 para toggle dev mode
            if (e.key === 'F3') {
                e.preventDefault();
                toggleDevMode();
                return;
            }

            // Detectar sequência D-E-V
            const now = Date.now();
            if (now - game.devMode.lastKeyTime > 1000) {
                game.devMode.keySequence = [];
            }
            game.devMode.keySequence.push(e.key.toUpperCase());
            game.devMode.lastKeyTime = now;

            if (game.devMode.keySequence.join('') === 'DEV') {
                toggleDevMode();
                game.devMode.keySequence = [];
                return;
            }

            // Comandos de dev mode
            handleDevModeKeys(e.key);

            // Pause
            if (e.key === 'p' || e.key === 'P') {
                if (game.state === 'playing') {
                    game.state = 'paused';
                    const menu = document.getElementById('menu');
                    menu.innerHTML = `
                        <h1>PAUSADO</h1>
                        <button onclick="resumeGame()">Continuar</button>
                        <button onclick="location.reload()">Menu Principal</button>
                    `;
                    menu.classList.remove('hidden');
                }
            }
        });

        document.addEventListener('keyup', (e) => {
            game.keys[e.key] = false;
        });

        window.resumeGame = function() {
            game.state = 'playing';
            document.getElementById('menu').classList.add('hidden');
            game.lastTime = performance.now();
        };

        // ============================================
        // INICIALIZAÇÃO
        // ============================================
        window.addEventListener('load', () => {
            game.ctx = game.canvas.getContext('2d');
            game.canvas.width = game.width;
            game.canvas.height = game.height;

            // Começar o loop (mesmo no menu, para possíveis animações)
            requestAnimationFrame(gameLoop);
        });
    </script>
</body>
</html>